## 第一章
1. C++原理需要明白
2. 项目要突出自己贡献、添加的功能和性能指数
3. 保持对难点敏感性
4. 建立自己笔记和博客
5. 要有自己的一套学习方法论
## 第二章
### 2.1时间复杂度
##### 算法运行次数随变量的改变而改变的程度。
时间复杂度，定性的描述了算法的运行时间，是指一般情况下默认数据规模足够大（不考虑系数项）
(1)常数阶<(logn)对数阶<(n)线性阶<(n2)平方阶<(n3)立方阶<(2n)指数阶
复杂表达式简化
一般省略常数项加法、常系数、只保留最复杂项
### 2.2程序运行时间
一般有一个超时时间如一秒 去限定程序
### 2.3计算机内存管理
内存分为代码区、数据区、堆区、栈区
代码区：存储二进制代码
数据区：全局变量、静态变量、常量
栈区：形参、局部变量、返回值等系统自动分配和回收
堆区：动态开辟空间，存放new出来的对象，需要手动回收
为什么要内存对齐
不是所有的硬件平台都能访问任意内存地址不上的数据，
内存对齐之后，CPU访问内存的速度会大大提升
因为CPU读内存数据是一块一块读的，比如说一块读4个字节，如果不对齐，一个char 一个int 连续的话，CPU就得读两块并且进行一次合并，节省内存空间，运行速度下降。实际上内存空间是够用的，希望提升运行速度。
### 2.4空间复杂度
##### 算法的存贮量随变量的改变而改变程度


for(n){i++}时间复杂度为O(n),空间复杂度O(1)
for(n){a[i++]=0} O(n),O(n)
fun（n）{ if（n>0）return fun (n-1); } O(n) O(n)
fun（n）{ if（n>0）return fun (n/2-1); } O(logn) O(logn)
fun（n）{ if（n>0）return fun (n/2-1)*return fun (n/2-1); } O(logn) O(n)
fun（n）{ if（n>0）return fun (n-1)*return fun (n-1); }O(n)O(2^n) 
##### 递归算法本质，
   时间复杂度是递归次数与每次递归的时间复杂度的乘积
   空间复杂度是递归深度与每次递归的空间复杂度的乘积
## 第三章 数组
### 3.1 数组的基本理论
一般数组是连续分布的
### 3.2 二分查找
二分需要保证 数列有序并且不重复
其实有两种写法 掌握一种就行
左闭右边闭合的形式
例子：LeetCode 704 二分查找